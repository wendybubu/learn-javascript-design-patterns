<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>构造函数继承</title>
</head>
<body>
<script>
    /**
     * 构造函数式继承：
     *   todo: 通过
     */
    // 声明父类
    function SuperClass(id) {
        this.books = ['js', 'html', 'css'];
        this.id = id;
    }
    // 父类声明原型方法
    SuperClass.prototype.showBook = function () {
        console.log(this.books);
    };
    // 声明子类
    function SubClass(id) {
        // 继承父类
        SuperClass.call(this, id);
    }
    var instance1 = new SubClass('001');
    var instance2 = new SubClass('002');
    instance1.books.push('设计模式');
    console.log(instance1.books);
    console.log(instance2.books);
    console.log(instance1.id);
    console.log(instance2.id);
    console.log(typeof instance1.showBook); // undefined
    console.log(typeof test); // undefined
//    test(); // Uncaught ReferenceError: test is not defined
    instance1.showBook(); // Uncaught TypeError: instance1.showBook is not a function
    /**
     * 构造函数式继承的缺点：
     *   父类的原型方法不会被子类继承（如果父类方法想被子类继承，就必须放在构造函数中，这样创建出来的每个实例抖会单独拥有一份而不能共用，违背了代码复用的原则）
     */
</script>
</body>
</html>